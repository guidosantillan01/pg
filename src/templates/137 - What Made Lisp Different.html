<html lang="en">

<head>
  <title>
    What Made Lisp Different
  </title>
</head>

<body>
  <h1>
    What Made Lisp Different
  </h1>
  <h2>
    December 2001 (rev. May 2002)
  </h2>
  <p>
    <i>
     (This article came about in response to some questions on
the
     <a href="http://ll1.mit.edu">
      LL1
     </a>
     mailing list.  It is now
incorporated in
     <a href="http://www.paulgraham.com/icad.html">
      Revenge of the Nerds
     </a>
     .)
    </i>
  </p>
  <p>
    When McCarthy designed Lisp in the late 1950s, it was a radical departure from existing languages, the most important of which was
    <a href="http://www.paulgraham.com/history.html">
     Fortran
    </a> .
  </p>
  <p>
    Lisp embodied nine new ideas:
  </p>
  <hr>
  <h3>
    1. Conditionals.
  </h3>
  <p>A conditional is an if-then-else construct. We take these for granted now. They were
    <a href="http://www-formal.stanford.edu/jmc/history/lisp/node2.html">
      invented
     </a> by McCarthy in the course of developing Lisp. (Fortran at that time only had a conditional goto, closely based on the branch instruction in the underlying hardware.) McCarthy, who was on the Algol committee, got conditionals into Algol,
    whence they spread to most other languages.
  </p>
  </hr>
  <h3>
    2. A function type.</h3>
  <p>
    In Lisp, functions are first class objects-- they're a data type just like integers, strings, etc, and have a literal representation, can be stored in variables, can be passed as arguments, and so on.
  </p>
  <h3>
    3. Recursion.</h3>
  <p>Recursion existed as a mathematical concept before Lisp of course, but Lisp was the first programming language to support it. (It's arguably implicit in making functions first class objects.)
  </p>
  <h3>
    4. A new concept of variables.</h3>
  <p>In Lisp, all variables are effectively pointers. Values are what have types, not variables, and assigning or binding variables means copying pointers, not what they point to.</p>
  <h3>
    5. Garbage-collection.
  </h3>
  <h3>
    6. Programs composed of expressions.</h3>
  <p>Lisp programs are trees of expressions, each of which returns a value. (In some Lisps expressions can return multiple values.) This is in contrast to Fortran and most succeeding languages, which distinguish between expressions and statements.</p>
  <p>
    It was natural to have this distinction in Fortran because (not surprisingly in a language where the input format was punched cards) the language was line-oriented. You could not nest statements. And so while you needed expressions for math to work, there
    was no point in making anything else return a value, because there could not be anything waiting for it.
  </p>
  <p>
    This limitation went away with the arrival of block-structured languages, but by then it was too late. The distinction between expressions and statements was entrenched. It spread from Fortran into Algol and thence to both their descendants.
  </p>
  <p>
    When a language is made entirely of expressions, you can compose expressions however you want. You can say either (using
    <a href="http://www.paulgraham.com/arc.html">
       Arc
      </a> syntax)
  </p>
  <xmp>
    (if foo (= x 1) (= x 2))
  </xmp>
  <p>
    or
  </p>
  <xmp>
    (= x (if foo 1 2))
  </xmp>
  <h3>
    7. A symbol type.</h3>
  <p>
    Symbols differ from strings in that you can test equality by comparing a pointer.</p>
  <h3>
    8. A notation for code using trees of symbols.</h3>
  <h3>
    9. The whole language always available.</h3>
  <p>There is no real distinction between read-time, compile-time, and runtime. You can compile or run code while reading, read or run code while compiling, and read or compile code at runtime.</p>
  <p>
    Running code at read-time lets users reprogram Lisp's syntax; running code at compile-time is the basis of macros; compiling at runtime is the basis of Lisp's use as an extension language in programs like Emacs; and reading at runtime enables programs
    to communicate using s-expressions, an idea recently reinvented as XML.</p>
  <hr>
  </hr>
  <p>
    When Lisp was first invented, all these ideas were far removed from ordinary programming practice, which was dictated largely by the hardware available in the late 1950s.
  </p>
  <p>
    Over time, the default language, embodied in a succession of popular languages, has gradually evolved toward Lisp. 1-5 are now widespread. 6 is starting to appear in the mainstream. Python has a form of 7, though there doesn't seem to be any syntax for
    it. 8, which (with 9) is what makes Lisp macros possible, is so far still unique to Lisp, perhaps because (a) it requires those parens, or something just as bad, and (b) if you add that final increment of power, you can no longer claim to have invented
    a new language, but only to have designed a new dialect of Lisp ; -)
  </p>
  <p>
    Though useful to present-day programmers, it's strange to describe Lisp in terms of its variation from the random expedients other languages adopted. That was not, probably, how McCarthy thought of it. Lisp wasn't designed to fix the mistakes in Fortran;
    it came about more as the byproduct of an attempt to
    <a href="http://www.paulgraham.com/rootsoflisp.html">
          axiomatize computation
         </a> .
  </p>
  <!--<p>
         Nor is this a complete list of ideas that began with Lisp
and spread to other languages.  These are only the initial
set.  Several more were developed in successive Lisp
implementations, including continuations,
multiple return values, rest parameters,
and assignment (setf) inversion.   </p>-->
  <p>
    This essay was originally published at
    <a href="http://www.paulgraham.com/diff.html?utm_source=pgebook">
          paulgraham.com
         </a>
  </p>
</body>

</html>
